abline(v=mean(subset(mydata.validation, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale, main='Deviated,MD')
abline(v=mean(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.validation, predictor==0)$lda_measure.scale, main='Straight,LDA')
abline(v=mean(subset(mydata.validation, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.validation, predictor==1)$lda_measure.scale, main='Deviated,LDA')
abline(v=mean(subset(mydata.validation, predictor==1)$lda_measure.scale),col="red")
stanDat.complete.validation <- list(y= matrix(c(mydata.validation$lda_measure.scale,mydata.validation$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.validation)), mydata.validation$predictor), ncol = 2),
N=nrow(mydata.validation), K=2, J=2)
fixEffit.complete.validation <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete.validation, iter=2000, chains =4)
print(fixEffit.complete.validation, pars = c("beta", 'L_sigma', 'L_Omega'), probs = c(0.025, 0.5, 0.975))
save(fixEffit.complete.validation, file='model_validation.RData')
rm(list = ls())
source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/mmaldona/Documents/GitHub/negationMT/negation_data_processed.RData')
# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)
#subset data to true trials
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)
#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)
# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)
# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)
par(mfrow=c(2,2))
hist(subset(mydata.true, predictor=0)$LogMaxDeviation.scale, main='Aff,MD')
abline(v=mean(subset(mydata.true, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==1)$LogMaxDeviation.scale, main='Neg,MD')
abline(v=mean(subset(mydata.true, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Aff,LDA')
abline(v=mean(subset(mydata.true, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.true, predictor==1)$lda_measure.scale, main='Neg,LDA')
abline(v=mean(subset(mydata.true, predictor==1)$lda_measure.scale),col="red")
par(mfrow=c(2,2))
hist(subset(mydata.true, predictor=0)$LogMaxDeviation.scale, main='Aff,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==1)$LogMaxDeviation.scale, main='Neg,MD' , xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Aff,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.true, predictor==1)$lda_measure.scale, main='Neg,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$lda_measure.scale),col="red")
rm(list = ls())
source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/mmaldona/Documents/GitHub/negationMT/negation_data_processed.RData')
# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)
#subset data to true trials
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)
#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)
# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)
# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)
par(mfrow=c(2,2))
hist(subset(mydata.true, predictor=0)$LogMaxDeviation.scale, main='Aff,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==1)$LogMaxDeviation.scale, main='Neg,MD' , xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Aff,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.true, predictor==1)$lda_measure.scale, main='Neg,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$lda_measure.scale),col="red")
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete, iter=2000, chains =4)
print(fixEffit.complete, pars = c("beta", 'L_sigma', 'L_Omega'), probs = c(0.025, 0.5, 0.975))
# save model just in case
save(fixEffit.complete, file='model_replicationDD.RData')
load('/Users/mmaldona/Documents/GitHub/negationMT/Validation.RData')
mydata.validation  <- calibration_data  %>% dplyr::select('lda_measure_full','Subject', 'MaxDeviation', 'Polarity')
#contrast coding -1/1 for predictor Polarity
mydata.validation$Polarity <- factor(mydata.validation$Polarity)
mydata.validation$predictor <- ifelse(mydata.validation$Polarity=='straight', 0, 1)
# log-transform the maximal deviation
mydata.validation$LogMaxDeviation <- log(mydata.validation$MaxDeviation)
# scale both measures with z-score
mydata.validation$LogMaxDeviation.scale <-  scale(mydata.validation$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.validation$lda_measure.scale <-  scale(mydata.validation$lda_measure_full, center=TRUE, scale=TRUE)
par(mfrow=c(2,2))
hist(subset(mydata.validation, predictor=0)$LogMaxDeviation.scale, main='Straight,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale, main='Deviated,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.validation, predictor==0)$lda_measure.scale, main='Straight,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.validation, predictor==1)$lda_measure.scale, main='Deviated,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==1)$lda_measure.scale),col="red")
stanDat.complete.validation <- list(y= matrix(c(mydata.validation$lda_measure.scale,mydata.validation$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.validation)), mydata.validation$predictor), ncol = 2),
N=nrow(mydata.validation), K=2, J=2)
fixEffit.complete.validation <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete.validation, iter=2000, chains =4)
print(fixEffit.complete.validation, pars = c("beta", 'L_sigma', 'L_Omega'), probs = c(0.025, 0.5, 0.975))
save(fixEffit.complete.validation, file='model_validation.RData')
?sampling
rm(list = ls())
source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
getwd()
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
setwd("~/Dropbox/GitHub/negationMT")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
getwd()
setwd()
setwd(/Users/moramaldonado/Dropbox/GitHub/negationMT)
setwd(Users/moramaldonado/Dropbox/GitHub/negationMT)
setwd("/Users/moramaldonado/Dropbox/GitHub/negationMT/")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
getwd()
setwd(getwd())
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/mmaldona/Documents/GitHub/negationMT/negation_data_processed.RData')
setwd(getwd())
load('/negation_data_processed.RData')
load('negation_data_processed.RData')
getwd()
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/negation_data_processed.RData')
View(negation_data_positions)
View(negation_data)
str(negation_data)
getwd()
negation_info <- read.csv(file="data_R/negation_data/negation_info.csv", header=TRUE, sep=",")
negation_data <- read.csv(file="data_R/negation_data/negation_data_simple.csv", header=TRUE, sep=",")
negation_data_positions <- read.csv(file="data_R/negation_data/negation_data_positions.csv", header=TRUE, sep=",")
x <- paste0('x', sprintf("%03d", c(1:101)))
y <- paste0('y', sprintf("%03d", c(1:101)))
## SUBJECT and TRIAL EXCLUSION ####
###  Excluding not natives English speakers
natives <- subset(negation_info, grepl('en',negation_info$Language, ignore.case=TRUE))
not_natives <- subset(negation_info, !(Subject %in% natives$Subject))
negation_info<- subset(negation_info, !(Subject %in% not_natives$Subject))
negation_data <- subset(negation_data, !(Subject %in% not_natives$Subject))
negation_data_positions <- subset(negation_data_positions, !(Subject %in% not_natives$Subject))
rm(natives, not_natives)
### Excluding unaccurate trials
non_accurate_data <- subset (negation_data, Accuracy==FALSE)
print('percentage of innaccurate trials:')
print(nrow(non_accurate_data)/nrow(negation_data))
negation_data <- subset(negation_data, Accuracy==TRUE)
negation_data_positions <- subset(negation_data_positions, Accuracy==TRUE)
load('LDA-Full.RData')
source("paper/R/norm_positions_LDA.R")
load('LDA-Full.RData')
source("paper/R/norm_positions_LDA.R")
normalized_positions.new <- normalized_positions %>%
dplyr::select(Subject, Item.number, Polarity, Response, one_of(all_data_columns))
normalized_positions.new_pca <- bind_cols(normalized_positions.new,
as.data.frame(predict(m_pca, normalized_positions.new)[,1:n_pca]))
lda_measure.new.df <- data_frame(
lda_measure=c(as.matrix(dplyr::select(normalized_positions.new_pca, starts_with("PC"))) %*% v_lda- b_lda),
Subject = normalized_positions.new_pca$Subject,
Item.number = normalized_positions.new_pca$Item.number,
Polarity = normalized_positions.new_pca$Polarity,
Response = normalized_positions.new_pca$Response)
##Including the relevant lda_measure in the data
negation_data$Subject <- factor(negation_data$Subject)
negation_data$Response <- factor(negation_data$Response)
negation_data$Polarity <- factor(negation_data$Polarity)
negation_data <- dplyr::full_join(lda_measure.new.df, negation_data, by=c("Subject", "Item.number", "Polarity", "Response"))
negation_data_positions$Subject <- factor(negation_data_positions$Subject)
negation_data_positions <- dplyr::full_join(lda_measure.new.df, negation_data_positions, by=c("Subject", "Item.number", "Polarity"))
### Coords only LDA
load('LDA-Coords.RData')
normalized_positions.new <- normalized_positions %>%
dplyr::select(Subject, Item.number, Polarity, Response, one_of(all_data_columns))
normalized_positions.new_pca <- bind_cols(normalized_positions.new,
as.data.frame(predict(m_pca, normalized_positions.new)[,1:n_pca]))
lda_measure.new.df <- data_frame(
lda_measure_coords=c(as.matrix(dplyr::select(normalized_positions.new_pca, starts_with("PC"))) %*% v_lda- b_lda),
Subject = normalized_positions.new_pca$Subject,
Item.number = normalized_positions.new_pca$Item.number,
Polarity = normalized_positions.new_pca$Polarity,
Response = normalized_positions.new_pca$Response)
negation_data <- dplyr::full_join(lda_measure.new.df, negation_data, by=c("Subject", "Item.number", "Polarity", "Response"))
negation_data_positions <- dplyr::full_join(lda_measure.new.df, negation_data_positions, by=c("Subject", "Item.number", "Polarity"))
source("paper/R/baseline.R")
View(negation_data)
str(negation_data)
View(normalized_positions.plot_true_af)
View(negation_data_positions)
View(negation_data)
View(negation_data.true_aff)
save(negation_data, negation_data_positions, negation_data_aff, file = "negation_data_processed.RData")
str(negation_data.true_aff)
save(negation_data, negation_data_positions, negation_data.true_aff, file = "negation_data_processed.RData")
unlink('adjectives/models_notebook_cache', recursive = TRUE)
mydata.baselines <- negation_data.true_aff %>% dplyr::select('lda_measure','Subject', 'MaxDeviation', 'Class')
rm(list = ls())
source("paper/R/packages-functions.R")
## DATA EXTRACTION ####
getwd()
negation_info <- read.csv(file="data_R/negation_data/negation_info.csv", header=TRUE, sep=",")
negation_data <- read.csv(file="data_R/negation_data/negation_data_simple.csv", header=TRUE, sep=",")
negation_data_positions <- read.csv(file="data_R/negation_data/negation_data_positions.csv", header=TRUE, sep=",")
x <- paste0('x', sprintf("%03d", c(1:101)))
y <- paste0('y', sprintf("%03d", c(1:101)))
natives <- subset(negation_info, grepl('en',negation_info$Language, ignore.case=TRUE))
not_natives <- subset(negation_info, !(Subject %in% natives$Subject))
negation_info<- subset(negation_info, !(Subject %in% not_natives$Subject))
negation_data <- subset(negation_data, !(Subject %in% not_natives$Subject))
negation_data_positions <- subset(negation_data_positions, !(Subject %in% not_natives$Subject))
rm(natives, not_natives)
non_accurate_data <- subset (negation_data, Accuracy==FALSE)
print('percentage of innaccurate trials:')
print(nrow(non_accurate_data)/nrow(negation_data))
negation_data <- subset(negation_data, Accuracy==TRUE)
negation_data_positions <- subset(negation_data_positions, Accuracy==TRUE)
load('LDA-Full.RData')
source("paper/R/norm_positions_LDA.R")
normalized_positions.new <- normalized_positions %>%
dplyr::select(Subject, Item.number, Polarity, Response, one_of(all_data_columns))
normalized_positions.new_pca <- bind_cols(normalized_positions.new,
as.data.frame(predict(m_pca, normalized_positions.new)[,1:n_pca]))
lda_measure.new.df <- data_frame(
lda_measure=c(as.matrix(dplyr::select(normalized_positions.new_pca, starts_with("PC"))) %*% v_lda- b_lda),
Subject = normalized_positions.new_pca$Subject,
Item.number = normalized_positions.new_pca$Item.number,
Polarity = normalized_positions.new_pca$Polarity,
Response = normalized_positions.new_pca$Response)
##Including the relevant lda_measure in the data
negation_data$Subject <- factor(negation_data$Subject)
negation_data$Response <- factor(negation_data$Response)
negation_data$Polarity <- factor(negation_data$Polarity)
negation_data <- dplyr::full_join(lda_measure.new.df, negation_data, by=c("Subject", "Item.number", "Polarity", "Response"))
negation_data_positions$Subject <- factor(negation_data_positions$Subject)
negation_data_positions <- dplyr::full_join(lda_measure.new.df, negation_data_positions, by=c("Subject", "Item.number", "Polarity"))
### Coords only LDA
load('LDA-Coords.RData')
normalized_positions.new <- normalized_positions %>%
dplyr::select(Subject, Item.number, Polarity, Response, one_of(all_data_columns))
normalized_positions.new_pca <- bind_cols(normalized_positions.new,
as.data.frame(predict(m_pca, normalized_positions.new)[,1:n_pca]))
lda_measure.new.df <- data_frame(
lda_measure_coords=c(as.matrix(dplyr::select(normalized_positions.new_pca, starts_with("PC"))) %*% v_lda- b_lda),
Subject = normalized_positions.new_pca$Subject,
Item.number = normalized_positions.new_pca$Item.number,
Polarity = normalized_positions.new_pca$Polarity,
Response = normalized_positions.new_pca$Response)
negation_data <- dplyr::full_join(lda_measure.new.df, negation_data, by=c("Subject", "Item.number", "Polarity", "Response"))
negation_data_positions <- dplyr::full_join(lda_measure.new.df, negation_data_positions, by=c("Subject", "Item.number", "Polarity"))
save(negation_data, negation_data_positions, file = "negation_data_processed.RData")
source("paper/R/baseline.R")
save(negation_data.true_aff, file = "baseline_negation_processed.RData")
names(negation_data.true_aff)
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/baseline_negation_processed.RData')
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/baseline_negation_processed.RData')
mydata.baselines <- negation_data.true_aff %>% dplyr::select('lda_measure','Subject', 'MaxDeviation', 'Class')
mydata.baselines$Class
mydata.baselines$predictor <- ifelse(mydata.baselines$Class=='straight', 0, 1)
mydata.baselines$LogMaxDeviation <- log(mydata.baselines$MaxDeviation)
# scale both measures with z-score
mydata.baselines$LogMaxDeviation.scale <-  scale(mydata.baselines$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.baselines$lda_measure.scale <-  scale(mydata.baselines$lda_measure, center=TRUE, scale=TRUE)
par(mfrow=c(2,2))
hist(subset(mydata.baselines, predictor=0)$LogMaxDeviation.scale, main='Straight,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.baselines, predictor==1)$LogMaxDeviation.scale, main='Uncertain,MD' , xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Straight,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.baselines, predictor==1)$lda_measure.scale, main='Uncertain,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==1)$lda_measure.scale),col="red")
hist(subset(mydata.baselines, predictor==1)$lda_measure.scale, main='Uncertain,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==1)$lda_measure.scale),col="red")
hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Straight,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==0)$lda_measure.scale),col="red")
par(mfrow=c(2,2))
hist(subset(mydata.baselines, predictor=0)$LogMaxDeviation.scale, main='Straight,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==0)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.baselines, predictor==1)$LogMaxDeviation.scale, main='Uncertain,MD' , xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==1)$LogMaxDeviation.scale),col="red")
hist(subset(mydata.baselines, predictor==0)$lda_measure.scale, main='Straight,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==0)$lda_measure.scale),col="red")
hist(subset(mydata.baselines, predictor==1)$lda_measure.scale, main='Uncertain,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.baselines, predictor==1)$lda_measure.scale),col="red")
stanDat.complete <- list(y= matrix(c(mydata.baselines$lda_measure.scale,mydata.baselines$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.baselines)), mydata.baselines$predictor), ncol = 2),
N=nrow(mydata.baselines), K=2, J=2)
stanDat.baselines.complete <- list(y= matrix(c(mydata.baselines$lda_measure.scale,mydata.baselines$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.baselines)), mydata.baselines$predictor), ncol = 2),
N=nrow(mydata.baselines), K=2, J=2)
fixEffit.complete <- stan(file="multivariate_outcome.stan", data = stanDat.baselines.complete, iter=2000, chains =4)
?file.path
fixEffit.complete <- stan(file=getwd()+"multivariate_outcome.stan", data = stanDat.baselines.complete, iter=2000, chains =4)
file.path(getwd(),'uu')
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.baselines.complete, iter=2000, chains =4)
stanDat.baselines.complete <- list(y= matrix(c(mydata.baselines$lda_measure.scale,mydata.baselines$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.baselines)), mydata.baselines$predictor), ncol = 2),
N=nrow(mydata.baselines), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.baselines.complete, iter=2000, chains =4)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.baselines.complete, iter=2000, chains =4)
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/negation_data_processed.RData')
# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)
#subset data to true trials
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)
#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)
# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)
# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete, iter=2000, chains =4)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/negation_data_processed.RData')
# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)
#subset data to true trials
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)
#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)
# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)
# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
library("rstan", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
?stan
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
require(rstan)
install.packages("StanHeaders")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
library("StanHeaders", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
remove.packages("StanHeaders")
install.packages("StanHeaders")
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("BH", "DBI", "DT", "Formula", "GGally", "Hmisc", "MASS", "Matrix", "ModelMetrics", "PKI", "RCurl", "RUnit", "Rcpp", "RcppEigen", "XML", "backports", "bayesplot", "bindr", "bindrcpp", "broom", "caTools", "car", "caret", "checkmate", "cluster", "colourpicker", "cowplot", "curl", "data.table", "devtools", "digest", "dplyr", "dygraphs", "ellipse", "evaluate", "forcats", "foreach", "foreign", "ggplot2", "ggpubr", "ggrepel", "ggsci", "git2r", "glue", "gridSVG", "gtools", "haven", "hexbin", "highr", "hms", "htmlTable", "htmlwidgets", "httpuv", "httr", "hunspell", "inline", "iterators", "kableExtra", "kimisc", "knitr", "lazyeval", "lme4", "loo", "lubridate", "matrixStats", "mgcv", "miniUI", "modelr", "munsell", "openssl", "pROC", "packrat", "pkgconfig", "plogr", "plotROC", "plotly", "progress", "pryr", "psych", "purrr", "pwr", "quantreg", "rJava", "readxl", "reshape", "reshape2", "rlang", "rmarkdown", "rpart", "rprojroot", "rsconnect", "rstan", "rstanarm", "rstantools", "rstudioapi", "scales", "scatterplot3d", "selectr", "shiny", "shinyjs", "shinystan", "sourcetools", "stringi", "stringr", "survival", "threejs", "tibble", "tidyr", "tidyselect", "tidytext", "tidyverse", "tokenizers", "viridis", "viridisLite", "withr", "xlsx", "xml2", "xtable", "xts", "yaml", "zoo"))
install.packages(c("devtools", "dplyr", "ggplot2", "rmarkdown", "tidyverse"))
install.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 ) # should be 10
library("rstan", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("rstantools", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
install.packages('devtools')
rm(list = ls())
#source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
source("/Users/moramaldonado/Dropbox/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
load('/Users/moramaldonado/Dropbox/GitHub/negationMT/negation_data_processed.RData')
# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)
#subset data to true trials
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)
#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)
# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)
# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
rstan:::get_CXX()
dotR <- file.path(Sys.getenv("HOME"), ".R", "Makevars")
cat(readLines(dotR), sep = "\n")
cat("\nCXXFLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function -Wno-macro-redefined",
file =  file.path(Sys.getenv("HOME"), ".R", "Makevars"), sep = "\n", append = FALSE)
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
N=nrow(mydata.true), K=2, J=2)
fixEffit.complete <- stan(file=file.path(getwd(),"multivariate_outcome.stan"), data = stanDat.complete, iter=2000, chains =4)
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
MAKEVARS <- file.path(dotR, "Makevars")
if (!file.exists(MAKEVARS)) file.create(MAKEVARS)
cat(
"\nCXXFLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function  -Wno-macro-redefined -Wno-unknown-pragmas",
"\nCC=clang",
"CXX=clang++ -arch x86_64 -ftemplate-depth-256",
file = MAKEVARS,
sep = "\n",
append = TRUE
)
# print the contents to the console
cat(readLines(MAKEVARS), sep = "\n")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 )
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
MAKEVARS <- file.path(dotR, "Makevars")
if (!file.exists(MAKEVARS)) file.create(MAKEVARS)
cat(
"\nCXXFLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function  -Wno-macro-redefined -Wno-unknown-pragmas",
"\nCC=clang",
"CXX=clang++ -arch x86_64 -ftemplate-depth-256",
file = MAKEVARS,
sep = "\n",
append = TRUE
)
# print the contents to the console
cat(readLines(MAKEVARS), sep = "\n")
remove.packages("rstan")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
system('defaults write org.R-project.R force.LANG en_US.UTF-8')
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 ) # should be 10
