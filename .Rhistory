facet_grid(~Polarity) +
theme(legend.position = "none")
ggplot(normalized_positions.plot, aes(x=X.Position, y=Y.Position, color=Polarity, group=grp)) +
geom_point(alpha=.7, size=.5) +
theme(legend.position = "none") +
ggtitle('Negation data: All Trajectories') +
scale_colour_brewer(palette="Set1")+
theme_minimal()+
facet_grid(~Expected_response) +
theme(legend.position = "none")
ggplot(normalized_positions.plot, aes(x=X.Position, y=Y.Position, color=Polarity, group=grp)) +
geom_point(alpha=.7, size=.5) +
theme(legend.position = "none") +
ggtitle('Negation data: All Trajectories') +
scale_colour_brewer(palette="Set1")+
theme_minimal()+
facet_grid(Polarity~Expected_response) +
theme(legend.position = "none")
normalized_positions.means.subject <-   ddply(normalized_positions.plot, c("Polarity", "Time.Step", "Expected_response", "Subject"),
function(normalized_positions.plot)c(X.Position.mean=mean(normalized_positions.plot$X.Position, na.rm=T)))
ggplot(normalized_positions.means.subject, aes(x=Time.Step, y=X.Position.mean, color=Subject, group=Subject)) +
geom_point(alpha=.4) + geom_line(alpha=.4) +
expand_limits(x=c(-1.5,1.5)) +
theme_minimal() +
ggtitle('Negation data: Subject means XPosition x TimeStep')+
theme(legend.position = "none") + facet_grid(Polarity~Expected_response)
normalized_positions.means.overall <- ddply(normalized_positions.means.subject, c("Polarity", "Time.Step", "Expected_response"),
function(normalized_positions.means.subject)c(X.Position.mean=mean(normalized_positions.means.subject$X.Position.mean, na.rm=T),
X.Position.se=se(normalized_positions.means.subject$X.Position, na.rm=T)))
ggplot(normalized_positions.means.overall, aes(x=Time.Step, y=X.Position.mean, color=Polarity, group=Polarity)) +
geom_point(alpha=.6) + geom_line() +
ggtitle('Negation data: Mean Xposition x Time step') +
scale_colour_brewer(palette="Set1")+
expand_limits(x=c(-1.5,1.5)) +
theme_minimal() +
theme(legend.position = "none") + facet_grid(.~Expected_response) +
geom_errorbar(aes(ymin=X.Position.mean-X.Position.se, ymax=X.Position.mean+X.Position.se), width=.1)
ggplot(normalized_positions.means.traj, aes(x=X.Position.mean, y=Y.Position.mean, color=Polarity, group=Polarity)) +
geom_point() +
ggtitle('Negation data: Mean Trajectories') +
geom_errorbarh(aes(xmin=X.Position.mean-X.Position.se, xmax=X.Position.mean+X.Position.se), alpha=.8) +
theme_minimal()+
theme(legend.position = "none") +
expand_limits(x=c(-1.5,1.5)) +
scale_colour_brewer(palette="Set1")+
facet_grid(.~Expected_response)
normalized_positions.means.subject <- ddply(normalized_positions.plot, c("Polarity", "Time.Step", "Expected_response", "Subject"),
function(normalized_positions.plot)c(X.Position.mean=mean(normalized_positions.plot$X.Position, na.rm=T),
Y.Position.mean=mean(normalized_positions.plot$Y.Position, na.rm=T)))
normalized_positions.means.traj <- ddply(normalized_positions.means.subject, c("Polarity", "Time.Step", "Expected_response"),
function(normalized_positions.means.subject)c(X.Position.mean=mean(normalized_positions.means.subject$X.Position, na.rm=T),
X.Position.se=se(normalized_positions.means.subject$X.Position, na.rm=T),
Y.Position.mean=mean(normalized_positions.means.subject$Y.Position, na.rm=T),
Y.Position.se=se(normalized_positions.means.subject$Y.Position, na.rm=T)))
ggplot(normalized_positions.means.traj, aes(x=X.Position.mean, y=Y.Position.mean, color=Polarity, group=Polarity)) +
geom_point() +
ggtitle('Negation data: Mean Trajectories') +
geom_errorbarh(aes(xmin=X.Position.mean-X.Position.se, xmax=X.Position.mean+X.Position.se), alpha=.8) +
theme_minimal()+
theme(legend.position = "none") +
expand_limits(x=c(-1.5,1.5)) +
scale_colour_brewer(palette="Set1")+
facet_grid(.~Expected_response)
plot_measure(negation_data, "lda_measure", "Polarity")
source('~/WebstormProjects/negationMT/R_scripts/negation_results.R', echo=TRUE)
normalized_positions.plot <- dplyr::full_join(lda_measure.new.df, normalized_positions.plot, by=c("Subject", "Item.number", "Polarity", "Response"))
normalized_positions.plot$lda_measure_cut <- cut(normalized_positions.plot$lda_measure, 5)
normalized_positions.plot <- dplyr::full_join(lda_measure.new.df, normalized_positions.plot, by=c("Subject", "Item.number", "Polarity"))
normalized_positions.plot$lda_measure_cut <- cut(normalized_positions.plot$lda_measure, 5)
plot_measure(negation_data, "lda_measure", "Polarity")
negation_data_true <- filter(negation_data, Response=='true')
plot_measure(negation_data_true, "lda_measure", "Polarity")
?title
plot_measure(negation_data_true, "lda_measure", "Polarity")
title('LDA distribution')
png(filename='R_scripts/graphs/LDA-negation.png', width = 7, height = 7, units = 'in', res = 300)
plot_measure(negation_data_true, "lda_measure", "Polarity")
title('LDA distribution')
dev.off()
png(filename='R_scripts/graphs/MaxLogRatio-negation.png', width = 7, height = 7, units = 'in', res = 300)
plot_measure(negation_data_true, "MaxLogRatio", "Polarity")
dev.off()
png(filename='R_scripts/graphs/MaxDeviation-negation.png', width = 7, height = 7, units = 'in', res = 300)
plot_measure(negation_data_true, "MaxDeviation", "Polarity")
dev.off()
View(negation_data)
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## EXTRACTING and ORGANIZING NEGATION DATA
source("R_scripts/negation/extracting_negation_data.R")
## ANALIZE NEGATION DATA
source("R_scripts/negation/negation_results.R")
source('~/WebstormProjects/negationMT/R_scripts/compile.R', echo=TRUE)
source('~/WebstormProjects/negationMT/R_scripts/compile.R', echo=TRUE)
source('~/WebstormProjects/negationMT/R_scripts/compile.R', echo=TRUE)
source('~/WebstormProjects/negationMT/R_scripts/compile.R', echo=TRUE)
source('~/WebstormProjects/negationMT/R_scripts/compile.R', echo=TRUE)
control_model.lda <- lmer(lda_measure ~ Polarity + Expected_response + Interaction * Item.number + (1+Polarity*Expected_response|Subject), data = mydata, REML=FALSE)
summary(control_model.lda)
m0.sentence.lda <- lmer(lda_measure ~ Expected_response + Interaction + (1+Polarity*Expected_response|Subject), data = mydata, REML=FALSE) #the value of intercept is not exactly the same as the one in my aggregate function, why?
anova(control_model.lda, m0.sentence.lda)
m0.interaction.lda <- lmer(lda_measure~ Polarity+Expected_response+ (1+Polarity*Expected_response|Subject), data = mydata, REML=FALSE) #the value of intercept is not exactly the same as the one in my aggregate function, why?
anova(control_model.lda, m0.interaction.lda)
m0.response.lda <- lmer(lda_measure ~ Polarity + Interaction + (1+Polarity*Expected_response|Subject), data = mydata, REML=FALSE) #the value of intercept is not exactly the same as the one in my aggregate function, why?
anova(control_model.lda, m0.response.lda)
rm(list = ls())
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
source("R_scripts/calibration/extract_calibration_data.R")
View(data_calibration)
View(calibration_data)
View(calibration_data)
View(data_calibration)
View(LDA_training.coord.accdist)
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
View(calibration_data)
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
library(MASS) # NB: this will mask dplyr::select
calibration_data = subset(calibration_data, Polarity != 'uncertain')
calibration_data$Subject <- factor(calibration_data$Subject)
normalized_positions.plot$Subject <- factor(normalized_positions.plot$Subject)
LDA_training.coord.dist(calibration_data)
View(calibration_data)
save(m_pca, v_lda, b_lda, n_pca, all_data_columns, file="LDA-Full.RData")
calibration_data <- dplyr::full_join(lda_measure.df, calibration_data, by=c("Subject", "Item.number", "Expected_response"))
normalized_positions.plot <- dplyr::full_join(lda_measure.df, normalized_positions.plot, by=c("Subject", "Item.number", "Expected_response"))
View(calibration_data)
plot_measure(calibration_data, "lda_measure_full", "Polarity")
LDA_training.coord.dist(calibration_data)
save(m_pca, v_lda, b_lda, n_pca, all_data_columns, file="LDA-Full.RData")
calibration_data <- dplyr::full_join(lda_measure.df, calibration_data, by=c("Subject", "Item.number", "Expected_response"))
normalized_positions.plot <- dplyr::full_join(lda_measure.df, normalized_positions.plot, by=c("Subject", "Item.number", "Expected_response"))
plot_measure(calibration_data, "lda_measure_full", "Polarity")
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
##CALIBRATION RESULTS
## Overall description of the results and computation of original/main LDA (subsection 2.2)
library(MASS) # NB: this will mask dplyr::select
## Subset to deviated and straight trials
calibration_data = subset(calibration_data, Polarity != 'uncertain')
calibration_data$Subject <- factor(calibration_data$Subject)
normalized_positions.plot$Subject <- factor(normalized_positions.plot$Subject)
## OVERALL PERFORMANCE (Plotting)
### Mean X position
normalized_positions.means.subject <-   ddply(normalized_positions.plot, c("Polarity", "Time.Step.Onset", "Subject"),
function(normalized_positions.plot)c(X.Position.mean=mean(normalized_positions.plot$X.Position, na.rm=T)))
normalized_positions.means <- ddply(normalized_positions.means.subject, c("Polarity", "Time.Step.Onset"),
function(normalized_positions.means.subject)c(X.Position.mean=mean(normalized_positions.means.subject$X.Position, na.rm=T), X.Position.se=se(normalized_positions.means.subject$X.Position, na.rm=T)))
ggplot(normalized_positions.means.subject, aes(x=Time.Step.Onset, y=X.Position.mean, color=Subject, group=Subject)) +
geom_point(size=0.5) + geom_line() +
expand_limits(x=c(-1.5,1.5)) + theme_minimal()+geom_vline(aes(xintercept=0))+
theme(legend.position = "none") + facet_grid(Polarity~.)
ggsave('calibration_mean_subject_XPosition.png', plot = last_plot(), scale = 1, dpi = 300,width = 10, path='R_scripts/graphs/calibration')
ggplot(subset(normalized_positions.means, Polarity!='uncertain'), aes(x=Time.Step.Onset, y=X.Position.mean, color=Polarity, group=Polarity)) +
geom_point(alpha=.6) + geom_line(alpha=.6) + theme_minimal()+ theme(legend.position = "none") +
ggtitle('Calibration Mean X-Position Onset at Change point') + geom_vline(aes(xintercept=0)) +  scale_colour_brewer(palette="Set1") +
geom_errorbar(aes(ymin=X.Position.mean-X.Position.se, ymax=X.Position.mean+X.Position.se), width=.1, alpha=.4)
ggsave('calibration_mean_XPosition.png', plot = last_plot(), scale = 1, dpi = 300,width = 10, path='R_scripts/graphs/calibration')
## Mean Trajectory
normalized_positions.means.subject <- ddply(subset(normalized_positions.plot, Polarity!='uncertain'), c("Polarity", "Time.Step", "Subject"),
function(normalized_positions.plot)c(X.Position.mean=mean(normalized_positions.plot$X.Position, na.rm=T),
Y.Position.mean=mean(normalized_positions.plot$Y.Position, na.rm=T)))
normalized_positions.means.traj <- ddply(normalized_positions.means.subject, c("Polarity", "Time.Step"),
function(normalized_positions.means.subject)c(X.Position.mean=mean(normalized_positions.means.subject$X.Position, na.rm=T),
X.Position.se=se(normalized_positions.means.subject$X.Position, na.rm=T),
Y.Position.mean=mean(normalized_positions.means.subject$Y.Position, na.rm=T),
Y.Position.se=se(normalized_positions.means.subject$Y.Position, na.rm=T)))
ggplot(normalized_positions.means.subject, aes(x=X.Position.mean, y=Y.Position.mean, color=Subject, group=Subject)) +
geom_point(size=0.5) +
ggtitle('Mean Trajectories per subject') +
theme_minimal() +
theme(legend.position = "top") +
expand_limits(x=c(-1.5,1.5)) +
facet_grid(Polarity~.)
ggsave('calibration_mean_subject_trajectory.png', plot = last_plot(), scale = 1, dpi = 300, width = 6, height = 6, path='R_scripts/graphs/calibration')
ggplot(normalized_positions.means.traj, aes(x=X.Position.mean, y=Y.Position.mean, color=Polarity, group=Polarity)) +
geom_point(alpha=.6, size=1) +
ggtitle('Calibration Mean trajectories')+
geom_errorbarh(aes(xmin=X.Position.mean-X.Position.se, xmax=X.Position.mean+X.Position.se)) +
theme_minimal() +
theme(legend.position = "none") +
scale_colour_brewer(palette="Set1")
ggsave('calibration_mean_trajectory.png', plot = last_plot(), scale = 1, dpi = 300, width = 6, height = 6,  path='R_scripts/graphs/calibration')
#### LDA CLASSIFIER ####
#LDA coords + delta + deltadelta based on coordinates
LDA_training.coord.dist(calibration_data)
save(m_pca, v_lda, b_lda, n_pca, all_data_columns, file="LDA-Full.RData")
calibration_data <- dplyr::full_join(lda_measure.df, calibration_data, by=c("Subject", "Item.number", "Expected_response"))
normalized_positions.plot <- dplyr::full_join(lda_measure.df, normalized_positions.plot, by=c("Subject", "Item.number", "Expected_response"))
plot_measure(calibration_data, "lda_measure_full", "Polarity")
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
## CALIBRATION RESULTS
### Overall description of the results and computation of original/main LDA (subsection 2.2)
source("R_scripts/calibration/calibration_results.R")
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
source("R_scripts/calibration/calibration_results.R")
View(auc.bins)
##2.2.3 Other predictors for the LDA
## Training and testing LDA with different predictors
#Different features in the classifier
for (b in 1: length(bins)) {
calibrationTrain <- subset(calibration_data, !(id %in% bins[[b]]$id))
calibrationTest <- subset(calibration_data, id %in% bins[[b]]$id)
## LDA *only* with Coordinates
###  TRAINING + TEST
LDA_training.coord(calibrationTrain)
LDA_test.coord(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord[b] <- lda.roc.te$auc
assign(paste0('lda_coord.roc.te',b), lda.roc.te)
## LDA with Coordinates, Velocity
###  TRAINING + TEST
LDA_training.coord.vel(calibrationTrain)
LDA_test.coord.vel(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.vel[b] <- lda.roc.te$auc
assign(paste0('lda_coord_vel.roc.te',b), lda.roc.te)
## LDA with Acceleration
###  TRAINING + TEST
LDA_training.acc(calibrationTrain)
LDA_test.dacc(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.acc[b] <- lda.roc.te$auc
assign(paste0('lda_acc.roc.te',b), lda.roc.te)
## LDA with Partial derivatives (Coords, Delta, DeltaDelta)
###  TRAINING + TEST
LDA_training.coord.delta.deltadelta(calibrationTrain)
LDA_test.coord.delta.deltadelta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.delta.deltadelta[b] <- lda.roc.te$auc
assign(paste0('lda_coord.delta.deltadelta.roc.te',b), lda.roc.te)
## LDA with Coordinates and Delta
###  TRAINING + TEST
LDA_training.coord.delta(calibrationTrain)
LDA_test.coord.delta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.delta[b] <- lda.roc.te$auc
assign(paste0('lda_coord.delta.roc.te',b), lda.roc.te)
## LDA with LogRatio
###  TRAINING + TEST
LDA_training.logratio(calibrationTrain)
LDA_test.logratio(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.logratio[b] <- lda.roc.te$auc
assign(paste0('lda_logratio.roc.te',b), lda.roc.te)
## LDA with DeltaDelta
###  TRAINING + TEST
LDA_training.deltadelta(calibrationTrain)
LDA_test.deltadelta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.deltadelta[b] <- lda.roc.te$auc
assign(paste0('lda_deltadelta.roc.te',b), lda.roc.te)
}
##2.2.3 Other predictors for the LDA
## Training and testing LDA with different predictors
#Different features in the classifier
for (b in 1: length(bins)) {
calibrationTrain <- subset(calibration_data, !(id %in% bins[[b]]$id))
calibrationTest <- subset(calibration_data, id %in% bins[[b]]$id)
## LDA *only* with Coordinates
###  TRAINING + TEST
LDA_training.coord(calibrationTrain)
LDA_test.coord(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord[b] <- lda.roc.te$auc
assign(paste0('lda_coord.roc.te',b), lda.roc.te)
## LDA with Coordinates, Velocity
###  TRAINING + TEST
LDA_training.coord.vel(calibrationTrain)
LDA_test.coord.vel(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.vel[b] <- lda.roc.te$auc
assign(paste0('lda_coord_vel.roc.te',b), lda.roc.te)
## LDA with Acceleration
###  TRAINING + TEST
LDA_training.dist.acc(calibrationTrain)
LDA_test.dist.acc(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.acc[b] <- lda.roc.te$auc
assign(paste0('lda_acc.roc.te',b), lda.roc.te)
## LDA with Partial derivatives (Coords, Delta, DeltaDelta)
###  TRAINING + TEST
LDA_training.coord.delta.deltadelta(calibrationTrain)
LDA_test.coord.delta.deltadelta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.delta.deltadelta[b] <- lda.roc.te$auc
assign(paste0('lda_coord.delta.deltadelta.roc.te',b), lda.roc.te)
## LDA with Coordinates and Delta
###  TRAINING + TEST
LDA_training.coord.delta(calibrationTrain)
LDA_test.coord.delta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.coord.delta[b] <- lda.roc.te$auc
assign(paste0('lda_coord.delta.roc.te',b), lda.roc.te)
## LDA with LogRatio
###  TRAINING + TEST
LDA_training.logratio(calibrationTrain)
LDA_test.logratio(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.logratio[b] <- lda.roc.te$auc
assign(paste0('lda_logratio.roc.te',b), lda.roc.te)
## LDA with DeltaDelta
###  TRAINING + TEST
LDA_training.deltadelta(calibrationTrain)
LDA_test.deltadelta(calibrationTest, v_lda, b_lda, m_pca, all_data_columns, n_pca)
#ROC and AUC
lda.score.te <- lda_measure_te.df$lda_measure
lda.label.te <- lda_measure_te.df$Deviation
lda.roc.te <- roc(lda.label.te, lda.score.te)
auc.bins$lda.deltadelta[b] <- lda.roc.te$auc
assign(paste0('lda_deltadelta.roc.te',b), lda.roc.te)
}
View(auc.bins)
plot.roc(smooth(lda_coord_vel.roc.te1), print.auc = FALSE, col="red", main='LDA with Coordinates')
plot.roc(smooth(lda_coord_vel.roc.te2), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te3), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te4), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te5), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te6), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te7), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te8), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te9), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te10), print.auc = FALSE, col="red", add=TRUE)
text(0.5, 0, paste("MEAN AUC=", round(mean(auc.bins$lda.coord.vel), digits=3)),
cex = .8)
dev.off()
# Coords + Velocity
png(filename='R_scripts/graphs/calibration/ROC:LDA-CoordsVelocity.png', width = 7, height = 7, units = 'in', res = 300)
plot.roc(smooth(lda_coord_vel.roc.te1), print.auc = FALSE, col="red", main='LDA with Coordinates')
plot.roc(smooth(lda_coord_vel.roc.te2), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te3), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te4), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te5), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te6), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te7), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te8), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te9), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_coord_vel.roc.te10), print.auc = FALSE, col="red", add=TRUE)
text(0.5, 0, paste("MEAN AUC=", round(mean(auc.bins$lda.coord.vel), digits=3)),
cex = .8)
dev.off()
rm(lda_coord_vel.roc.te1,lda_coord_vel.roc.te2,lda_coord_vel.roc.te10,lda_coord_vel.roc.te3, lda_coord_vel.roc.te4, lda_coord_vel.roc.te5,lda_coord_vel.roc.te6,lda_coord_vel.roc.te7,lda_coord_vel.roc.te8,lda_coord_vel.roc.te9)
png(filename='R_scripts/graphs/ROC:LDA-FULL.png', width = 7, height = 7, units = 'in', res = 300)
plot.roc(smooth(lda_full.roc.te1), print.auc = FALSE, col="red", main='Original Linear Discriminant Analysis (Coord, Vel, Acc)')
plot.roc(smooth(lda_full.roc.te2), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te3), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te4), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te5), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te6), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te7), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te8), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te9), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_full.roc.te10), print.auc = FALSE, col="red", add=TRUE)
text(0.5, 0, paste("MEAN AUC=", round(mean(auc.bins$lda.full), digits=3)),
cex = 1)
dev.off()
png(filename='R_scripts/graphs/calibration/ROC:LDA-Acceleration.png', width = 7, height = 7, units = 'in', res = 300)
plot.roc(smooth(lda_acc.roc.te1), print.auc = FALSE, col="red", main='LDA with Acceleration ')
plot.roc(smooth(lda_acc.roc.te2), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te3), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te4), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te5), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te6), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te7), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te8), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te9), print.auc = FALSE, col="red", add=TRUE)
plot.roc(smooth(lda_acc.roc.te10), print.auc = FALSE, col="red", add=TRUE)
text(0.5, 0, paste("MEAN AUC=", round(mean(auc.bins$lda.acc), digits=3)),
cex = .8)
dev.off()
rm(lda_acc.roc.te1,lda_acc.roc.te2,lda_acc.roc.te3,lda_acc.roc.te4,lda_acc.roc.te5,lda_acc.roc.te6,lda_acc.roc.te7,lda_acc.roc.te8,lda_acc.roc.te9,lda_acc.roc.te10)
#### CALIBRATION DATA ####
## CLEAN ENVIRONMENT
rm(list = ls())
## CHARGE PACKAGES
source("R_scripts/packages.R")
## CHARGE FUNCTIONS FOR LDA TRAINING
source("R_scripts/calibration/LDA.R")
## EXTRACTING and ORGANIZING CALIBRATION DATA
# Extracts data from calibration (last version: June 2017) into calibration_data
# Excludes innacurate trials and print the percentage
# Creates data frame normalized_positions.plot: each row contains one time.step with X.Position, Y.Position, Raw.Acceleration, Raw.Time columns among others
source("R_scripts/calibration/extract_calibration_data.R")
## CALIBRATION RESULTS
### Overall description of the results and computation of original/main LDA (subsection 2.2)
source("R_scripts/calibration/calibration_results.R")
source("R_scripts/calibration/comparison_other_predictors.R")
source('~/WebstormProjects/negationMT/R_scripts/calibration/comparison_other_predictors.R', echo=TRUE)
source('~/WebstormProjects/negationMT/R_scripts/calibration/comparison_other_predictors.R', echo=TRUE)
rm(list = ls())
source("R_scripts/packages.R")
source("R_scripts/negation/extracting_negation_data.R")
View(negation_data)
source("R_scripts/negation/negation_results.R")
