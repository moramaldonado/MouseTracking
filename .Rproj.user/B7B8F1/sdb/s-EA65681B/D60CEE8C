{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Pretest_Analyses\"\nauthor: \"Mora Maldonado\"\ndate: \"10/24/2016\"\noutput:\n  html_document:\n    toc: yes\n---\n\n\n```{r, warning=FALSE, results='hide', cache.comments=TRUE, echo=FALSE, message=FALSE}\nrequire(reshape2)\nrequire(plyr)\nrequire(sciplot)\nrequire(ggplot2)\nrequire(grid)\nrequire(lme4)\nrequire(knitr)\nrequire(dplyr)\nrequire(car)\nrequire(languageR)\n#require(RePsychLing)\nrequire(devtools)\nrequire(rocauc)\n\n```\n\n```{r se-fn, echo=FALSE}\n# Standard error of the mean\nse <- function(x, ...) {\n    n <- length(x)\n    return(sd(x, ...)/sqrt(n))\n}\n```\n\n```{r bhatt, echo=FALSE}\n# Bhattacharyya distance\nbhatt <- function(x1, x2) {\n    m1 <- mean(x1, na.rm=T)\n    m2 <- mean(x2, na.rm=T)\n    v1 <- var(x1, na.rm=T)\n    v2 <- var(x2, na.rm=T)\n    result <- 0.25*log(0.25*(v1/v2 + v2/v1 + 2)) + 0.25*((m1 - m2)^2)/(v1 + v2)\n    return(result)\n}\n```\n\n```{r tstat, echo=FALSE}\ntstat <- function(x1, x2) {\n    m1 <- mean(x1, na.rm=T)\n    m2 <- mean(x2, na.rm=T)\n    v1 <- var(x1, na.rm=T)\n    v2 <- var(x2, na.rm=T)\n    n1 <- length(x1)\n    n2 <- length(x2)\n    result <- (m1 - m2)/sqrt(v1/n1 + v2/n2)\n    return(result)\n}\n```\n\n\n###Multiplot function (extrated from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/)\n```{r Multiplot, echo=FALSE}\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  library(grid)\n\n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n\n  numPlots = length(plots)\n\n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                    ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n\n if (numPlots==1) {\n    print(plots[[1]])\n\n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n```\n\n\n##Data Extraction\n```{r Data Extraction}\n#setwd(\"/Users/moramaldonado/Dropbox/NEGATION/Pretest\")\ninformation <- read.csv('Subject_Info.csv', header = TRUE)\nresults <- read.csv('Results.csv', header = TRUE)\nresults <- subset(results, Adj.pair!='')\n```\n\n##Exclusion criteria\n###Excluding not-native speakers\n```{r Not natives}\nnatives <- subset(information, grepl('en',information$language, ignore.case=TRUE))\nnot_natives <- subset(information, !(subject %in% natives$subject))\n#information <- subset(information, (subject %in% natives$subject))\n#results <- subset(results, !(subject %in% not_natives$subject))\n```\n\nI don't think we want to exclude anyone else. \n```{r, fig.height=10, fig.width=17}\nresponses <- ddply(results, c(\"Polarity\",\"Adj.pair\", \"Exemplar\"),\n            function(responses)c(response=mean(responses$answer, na.rm=T), se=se(responses$answer, na.rm=T)))\n\nplot1 <- ggplot(responses, aes(x=Exemplar, y=response, color=Polarity, group=Polarity)) +\n    geom_line(alpha=1/2) +\n    geom_point(alpha=1/2) +\n    geom_errorbar(aes(ymin=response-se,   ymax=response+se), width=.1) +\n    ggtitle(\" \") + facet_wrap(~Adj.pair, scales='free', ncol=2) \n\nplot1 + theme_bw() + theme(panel.background= element_blank(), panel.grid.minor = element_blank(), axis.text.x = element_text(colour='black', size=10, lineheight=.8), axis.title.y= element_text(face=\"bold\", colour='grey55', size=11), axis.text.y = element_text(colour='black', size=10), axis.ticks = element_blank()) \n\n```\n\n##Analyses\n###1. Compute ROC curve\n```{r fig.width=15, fig.height=10}\n#I took this easy function from RBloggers (https://www.r-bloggers.com/roc-curves-in-two-lines-of-r-code/)\n\nsimple_roc <- function(labels, scores){labels <- labels[order(scores, decreasing=TRUE)]\n  TPR <- c(0, cumsum(labels)/sum(labels))\n  FPR <- c(0, cumsum(!labels)/sum(!labels))\n  data.frame(TPR,FPR)\n  }\nlibrary(scales)\nresults$scores <- results$answer\nresults$scores <- rescale(results$scores, to = c(0, 100))\nresults$label <- results$Polarity == 'Pos'\n\nroc <- ddply(results, c(\"Exemplar\",\"Adj.pair\"), function(roc) {\n  as.data.frame(simple_roc(roc$label, roc$scores))\n} )\n\n#Plotting the ROC for each pair\nnames = c()\nfor (i in factor(levels(roc$Adj.pair))){\n  d <- subset(roc, Adj.pair==i)\n  name <- paste(\"plot\", i, sep='_')\n  names <- c(names, name)\n  assign(name, ggplot(d, aes(y = TPR, x = FPR))+geom_point()+geom_line() +ggtitle(as.character(i))+ geom_abline(intercept = 0, colour = \"red\", size = .2, linetype=\"dotted\") + facet_wrap(~Exemplar) + theme_bw() + theme(plot.title = element_text(size=8), panel.background= element_blank(), panel.grid.minor = element_blank(), axis.text.x = element_text(colour='black', size=8), axis.title.x= element_text(face=\"bold\", colour='grey55', size=8), axis.title.y= element_text(face=\"bold\", colour='grey55', size=8), axis.text.y = element_text(colour='black', size=8), axis.ticks = element_blank()) + theme(legend.position=\"none\", strip.text.x = element_text(size=8)))\n  \n}\n\nmultiplot(`plot_big/small`,`plot_dark/bright`,`plot_expensive/inexpensive`,cols=2)\nmultiplot(`plot_fast/slow`,`plot_healthy/unhealthy`,`plot_thin/thick`,cols=2)\nmultiplot(`plot_hot/cold`,`plot_light/heavy`,`plot_loud/quiet`,cols=2)\n\n```\n\n###2. Compute AUC and pick the 2 items that maximize AUC\n```{r}\nauc_df <- ddply(roc, c(\"Exemplar\",\"Adj.pair\"), function(auc_df) {\n  c(auc = auc(auc_df$TPR, auc_df$FPR))} )\n\npick_min <- function(name1, name2){\n  func <- min(name1)\n  exemplar <- name2[name1 == func]\n  data.frame(func,exemplar)\n}\npick_max <- function(name1, name2){\n  func <- max(name1)\n  exemplar <- name2[name1 == func]\n  data.frame(func,exemplar)\n}\nmin <- ddply(auc_df, c(\"Adj.pair\"), function(x) {\n  as.data.frame(pick_min(x$auc,x$Exemplar))})\n\nmax <- ddply(auc_df, c(\"Adj.pair\"), function(x) {\n  as.data.frame(pick_max(x$auc,x$Exemplar))}) \n\nkable(min)\nkable(max)\n\nggplot(auc_df, aes(y=auc, x=0, fill=Exemplar)) + geom_bar(position=\"dodge\", colour=\"black\", stat=\"identity\") + facet_wrap(~ Adj.pair)\n```\n\n\n\n###3. Compute the difference in mean rating between positive and negative items\n\n\n\n```{r}\nbhatt_df <- ddply(results %>% filter(Trial.type == \"EI\"), c(\"Exemplar\",\"Adj.pair\"),\n                  function(d) { c(bhatt = bhatt(\n                            d[d$Polarity==\"Neg\",]$answer, \n                            d[d$Polarity==\"Pos\",]$answer))} )\n\ntstat_df <- ddply(results %>% filter(Trial.type == \"EI\") , c(\"Exemplar\",\"Adj.pair\"),\n                  function(d) { c(tstat = tstat(\n                            d[d$Polarity==\"Neg\",]$answer, \n                            d[d$Polarity==\"Pos\",]$answer))} )\nmean(abs(tstat_df$tstat))\n\ntstat_df <- ddply(results, c(\"Exemplar\",\"Adj.pair\"),\n                  function(d) { c(tstat = tstat(\n                            d[d$Polarity==\"Neg\",]$answer, \n                            d[d$Polarity==\"Pos\",]$answer))} )\n\n\n\nggplot(subset(tstat_df, Adj.pair!='thin/thick' & Adj.pair!='expensive/inexpensive'), aes(x=Exemplar, y=tstat, color=Adj.pair))+geom_point()+geom_text(aes(label=Exemplar),hjust=0, vjust=0) + geom_hline(aes(yintercept=19)) + geom_hline(aes(yintercept=-19))\n\n\ntstat_df_selection <- subset(tstat_df, Adj.pair!='thin/thick' & Adj.pair!='expensive/inexpensive')\ntstat_df_selection$tstat <- abs(tstat_df_selection$tstat)\ntstat_df_selection$closer <- abs(tstat_df_selection$tstat-19)\n\nlibrary(xlsx)\nwrite.xlsx(tstat_df_selection, \"items.xlsx\")\n\n```\n\n\n1. Taking out thin/thick and expensive/inexpensive because of high variability??\n\n2. Choosing the two exemplars that are closer to the relative mean. \n\n\n\n\n\nSelection of fillers?\n```{r}\n\ntstat_df_filler <- ddply(results %>% filter(Trial.type == \"Fillers\") , c(\"Exemplar\",\"Adj.pair\"),\n                  function(d) { c(tstat = tstat(\n                            d[d$Polarity==\"Neg\",]$answer, \n                            d[d$Polarity==\"Pos\",]$answer))} )\n\n\nggplot(subset(tstat_df_filler, Adj.pair!='thin/thick' & Adj.pair!='expensive/inexpensive'), aes(x=Exemplar, y=tstat, color=Adj.pair))+geom_point()+geom_text(aes(label=Exemplar),hjust=0, vjust=0) + geom_hline(aes(yintercept=0)) \n\n\n```\n\n\n\n\nLooking at reading times\n```{r}\nmean_rt <- ddply(results, .(Exemplar, Adj.pair), summarize, mean_rt=mean(log(rt)))\n```",
    "created" : 1485254813361.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3868060426",
    "id" : "D60CEE8C",
    "lastKnownWriteTime" : 1479405312,
    "last_content_update" : 1479405312,
    "path" : "~/Dropbox/NEGATION/Pretest/Pretest_Analyses.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}