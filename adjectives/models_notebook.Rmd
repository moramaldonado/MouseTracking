---
title: "Stan models"
output: html_notebook
---

### Pre-steps

#### Clear environment, charge packages and functions
```{r Clear environment, charge packages and functions}
rm(list = ls())
source("/Users/mmaldona/Documents/GitHub/negationMT/paper/R/packages-functions.R")
require('rstan')
```
### Data from Dale and Duran replication, and organizing
```{r Load negation data and organizing}
load('/Users/mmaldona/Documents/GitHub/negationMT/negation_data_processed.RData')

# subset data to just true affirmative trials (for super simple model)
mydata.affirmative.true <- subset(negation_data, Polarity=='P' & Response=='true')
mydata.affirmative.true <- mydata.affirmative.true  %>% dplyr::select('lda_measure','Subject','Adjective')
mydata.affirmative.true$Adjective <- factor(mydata.affirmative.true$Adjective)

#subset data to true trials 
mydata.true <- subset(negation_data, Response=='true')
mydata.true <- mydata.true  %>% dplyr::select('lda_measure','Subject','Adjective', 'MaxDeviation', 'Polarity')
mydata.true$Adjective <- factor(mydata.true$Adjective)

#contrast coding -1/1 for predictor Polarity
mydata.true$Polarity <- factor(mydata.true$Polarity)
mydata.true$predictor <- ifelse(mydata.true$Polarity=='P', 0, 1)

# log-transform the maximal deviation
mydata.true$LogMaxDeviation <- log(mydata.true$MaxDeviation)

# scale both measures with z-score
mydata.true$LogMaxDeviation.scale <-  scale(mydata.true$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.true$lda_measure.scale <-  scale(mydata.true$lda_measure, center=TRUE, scale=TRUE)

```

#### Distribution of LDA and MD
```{r Distribution of LDA and MD after scaling, echo=FALSE, message=FALSE, warning=FALSE}
par(mfrow=c(2,2))
hist(subset(mydata.true, predictor=0)$LogMaxDeviation.scale, main='Aff,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$LogMaxDeviation.scale),col="red")

hist(subset(mydata.true, predictor==1)$LogMaxDeviation.scale, main='Neg,MD' , xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$LogMaxDeviation.scale),col="red")

hist(subset(mydata.true, predictor==0)$lda_measure.scale, main='Aff,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==0)$lda_measure.scale),col="red")

hist(subset(mydata.true, predictor==1)$lda_measure.scale, main='Neg,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.true, predictor==1)$lda_measure.scale),col="red")
```

### Stan multivariate model 
*NB:I am including this model here, but for some reason I am not able to run it *from* here, so I am running it from the file directly.*

```{stan Stan model, output.var='multivariate.stan', results='hide'}
// data block: declaration of the variables in the data object stanDat: specifications about the data type (real, integers)
data {
      int<lower=0> N; //number of observations
      int<lower=1> K; //number of variables
      int<lower=1> J; //number of variables
      vector[J] x[N]; // predictor (polarity)
      vector[K] y[N]; // outcome (lda measure and maximal deviation)
    }
// parameters block: three parameters: the fixed slope, the fixed intercept and the SD of the error. (priors)
parameters {
      matrix[K, J] beta; // slope and intercept
      cholesky_factor_corr[K] L_Omega; //  correlation matrix btw the two dependent measures
      vector<lower=0>[K] L_sigma; // variance and covariance matrix
} 
// if priors are underspecified in the model, Stan assumes uniform priors on parameters ovr their leval values as determined by their declared constraints.
model {
      vector[K] mu[N];
      matrix[K, K] L_Sigma;
      
      for (n in 1:N)
        mu[n] = beta * x[n];
      
      L_Sigma = diag_pre_multiply(L_sigma, L_Omega);
      to_vector(beta) ~ normal(0, 5);
      L_Omega ~ lkj_corr_cholesky(4);
      L_sigma ~ cauchy(0, 2.5);
      y ~ multi_normal_cholesky(mu, L_Sigma);
    }
    
```

### Applying multivariate model to D&D replication data
*NB: I am doing this with lda measure and maximal deviation* The data is the same as before (mydata.true) 


```{r MULTIVARIATE MODEL ON DALE AND DURAN REPLICATION, echo=TRUE, results='hide'}
#prepare data for stan
stanDat.complete <- list(y= matrix(c(mydata.true$lda_measure.scale,mydata.true$LogMaxDeviation.scale),ncol=2),
                x=matrix(c(rep(1, nrow(mydata.true)), mydata.true$predictor), ncol = 2),
                N=nrow(mydata.true), K=2, J=2)

fixEffit.complete <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete, iter=2000, chains =4)


```

#### Results model fit to Dale and Duran replication data

**How to read the results?**

* 
* beta[1,1] is the first intercept (LDA)
* beta[1,2] is the first slope (LDA)
* beta[2,1] is the second intercept (MD)
* beta[2,2] is the second slope (MD)
* Omega are the elements of the correlation matrix
* Sigma are the elements of the covariance matrix


```{r Results model fit to Dale and Duran replication data}
print(fixEffit.complete, pars = c("beta", 'L_sigma', 'L_Omega'), probs = c(0.025, 0.5, 0.975))

# save model just in case
save(fixEffit.complete, file='model_replicationDD.RData')

```


### Applying multivariate model to validation data

```{r Validation data}
load('/Users/mmaldona/Documents/GitHub/negationMT/Validation.RData')

mydata.validation  <- calibration_data  %>% dplyr::select('lda_measure_full','Subject', 'MaxDeviation', 'Polarity')

#contrast coding -1/1 for predictor Polarity
mydata.validation$Polarity <- factor(mydata.validation$Polarity)
mydata.validation$predictor <- ifelse(mydata.validation$Polarity=='straight', 0, 1)


# log-transform the maximal deviation
mydata.validation$LogMaxDeviation <- log(mydata.validation$MaxDeviation)



# scale both measures with z-score
mydata.validation$LogMaxDeviation.scale <-  scale(mydata.validation$LogMaxDeviation, center=TRUE, scale=TRUE)
mydata.validation$lda_measure.scale <-  scale(mydata.validation$lda_measure_full, center=TRUE, scale=TRUE)


par(mfrow=c(2,2))
hist(subset(mydata.validation, predictor=0)$LogMaxDeviation.scale, main='Straight,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==0)$LogMaxDeviation.scale),col="red")

hist(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale, main='Deviated,MD', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==1)$LogMaxDeviation.scale),col="red")

hist(subset(mydata.validation, predictor==0)$lda_measure.scale, main='Straight,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==0)$lda_measure.scale),col="red")

hist(subset(mydata.validation, predictor==1)$lda_measure.scale, main='Deviated,LDA', xlim=c(-3,3), breaks=5)
abline(v=mean(subset(mydata.validation, predictor==1)$lda_measure.scale),col="red")

```


```{r, results='hide'}
stanDat.complete.validation <- list(y= matrix(c(mydata.validation$lda_measure.scale,mydata.validation$LogMaxDeviation.scale),ncol=2),
                         x=matrix(c(rep(1, nrow(mydata.validation)), mydata.validation$predictor), ncol = 2),
                         N=nrow(mydata.validation), K=2, J=2)


fixEffit.complete.validation <- stan(file="/Users/mmaldona/Documents/GitHub/negationMT/multivariate_outcome.stan", data = stanDat.complete.validation, iter=2000, chains =4)
```

#### Results model fit to Dale and Duran replication data
```{r Results model fit to validation data}
print(fixEffit.complete.validation, pars = c("beta", 'L_sigma', 'L_Omega'), probs = c(0.025, 0.5, 0.975))

save(fixEffit.complete.validation, file='model_validation.RData')
```


